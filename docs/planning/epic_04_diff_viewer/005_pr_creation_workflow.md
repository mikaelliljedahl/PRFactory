# Phase 5: PR Creation Workflow

**Status**: Not Started
**Estimated Effort**: 5-6 hours
**Dependencies**: Phase 4 (Blazor UI)
**Risk Level**: Medium (multi-platform PR creation)

## Objective

Implement complete PR creation workflow including:
- Retrieving plan artifacts
- Building formatted PR description
- Creating PR via platform provider (GitHub, Bitbucket, Azure DevOps)
- State transitions and cleanup

## Tasks

### Task 5.1: Enhance `BuildPRDescriptionAsync` Method

**File**: `/src/PRFactory.Infrastructure/Application/TicketApplicationService.cs`

**Replace placeholder implementation** from Phase 2:

```csharp
private async Task<string> BuildPRDescriptionAsync(Ticket ticket)
{
    _logger.LogDebug("Building PR description for ticket {TicketId}", ticket.Id);

    // Retrieve latest plan artifacts (if available)
    var plan = await _planRepository.GetLatestByTicketIdAsync(ticket.Id);

    if (plan == null)
    {
        _logger.LogWarning("No plan found for ticket {TicketId}, using basic description", ticket.Id);
        return BuildBasicPRDescription(ticket);
    }

    return BuildDetailedPRDescription(ticket, plan);
}

private string BuildBasicPRDescription(Ticket ticket)
{
    return $@"## {ticket.Key}: {ticket.Title}

### Description

{ticket.Description}

---

*Generated by PRFactory*
";
}

private string BuildDetailedPRDescription(Ticket ticket, Plan plan)
{
    var description = new StringBuilder();

    description.AppendLine($"## {ticket.Key}: {ticket.Title}");
    description.AppendLine();

    // Ticket description
    description.AppendLine("### Description");
    description.AppendLine(ticket.Description);
    description.AppendLine();

    // User stories (if available)
    if (!string.IsNullOrEmpty(plan.UserStories))
    {
        description.AppendLine("### User Stories");
        description.AppendLine(plan.UserStories);
        description.AppendLine();
    }

    // API design (if available)
    if (!string.IsNullOrEmpty(plan.ApiDesign))
    {
        description.AppendLine("### API Design");
        description.AppendLine("```yaml");
        description.AppendLine(plan.ApiDesign);
        description.AppendLine("```");
        description.AppendLine();
    }

    // Database schema (if available)
    if (!string.IsNullOrEmpty(plan.DatabaseSchema))
    {
        description.AppendLine("### Database Changes");
        description.AppendLine("```sql");
        description.AppendLine(plan.DatabaseSchema);
        description.AppendLine("```");
        description.AppendLine();
    }

    // Test cases (if available)
    if (!string.IsNullOrEmpty(plan.TestCases))
    {
        description.AppendLine("### Test Cases");
        description.AppendLine(plan.TestCases);
        description.AppendLine();
    }

    // Implementation steps (if available)
    if (!string.IsNullOrEmpty(plan.ImplementationSteps))
    {
        description.AppendLine("### Implementation Steps");
        description.AppendLine(plan.ImplementationSteps);
        description.AppendLine();
    }

    // Footer
    description.AppendLine("---");
    description.AppendLine($"*Generated by PRFactory on {DateTime.UtcNow:yyyy-MM-dd HH:mm} UTC*");

    return description.ToString();
}
```

**Add dependency**:

```csharp
private readonly IPlanRepository _planRepository;

// Add to constructor
public TicketApplicationService(
    // ... existing parameters ...
    IPlanRepository planRepository)
{
    // ... existing assignments ...
    _planRepository = planRepository ?? throw new ArgumentNullException(nameof(planRepository));
}
```

### Task 5.2: Implement State Transitions

**Update** `CreatePullRequestAsync` method in `/src/PRFactory.Infrastructure/Application/TicketApplicationService.cs`:

```csharp
public async Task<PullRequestCreationResult> CreatePullRequestAsync(Guid ticketId, string? approvedBy = null)
{
    _logger.LogInformation("Creating pull request for ticket {TicketId}, approved by {ApprovedBy}",
        ticketId, approvedBy ?? "unknown");

    try
    {
        // Get ticket and validate state
        var ticket = await _ticketRepo.GetByIdAsync(ticketId);
        if (ticket == null)
        {
            return PullRequestCreationResult.Failed($"Ticket {ticketId} not found");
        }

        if (ticket.State != WorkflowState.Implementing)
        {
            return PullRequestCreationResult.Failed(
                $"Ticket is not in Implementing state (current: {ticket.State})");
        }

        // Get repository and workspace paths
        var repository = ticket.Repository;
        var repoPath = _workspaceService.GetRepositoryPath(ticketId);
        var branchName = $"feature/{ticket.Key}";

        // Push branch to remote
        _logger.LogInformation("Pushing branch {BranchName} for ticket {TicketId}", branchName, ticketId);

        await _localGitService.PushAsync(repoPath, branchName, repository.AccessToken);

        // Build PR description with plan artifacts
        var prDescription = await BuildPRDescriptionAsync(ticket);

        // Create PR via platform provider (GitHub, Bitbucket, Azure DevOps)
        _logger.LogInformation("Creating pull request on {Platform} for ticket {TicketId}",
            repository.GitPlatform, ticketId);

        var createPrRequest = new CreatePullRequestRequest
        {
            SourceBranch = branchName,
            TargetBranch = repository.DefaultBranch ?? "main",
            Title = $"{ticket.Key}: {ticket.Title}",
            Description = prDescription
        };

        var pr = await _gitPlatformProvider.CreatePullRequestAsync(repository.Id, createPrRequest);

        // Update ticket state to PRCreated
        ticket.MarkPRCreated(pr.Number, pr.Url);
        await _ticketRepo.UpdateAsync(ticket);

        _logger.LogInformation("Ticket {TicketId} state updated to PRCreated: {PrUrl}", ticketId, pr.Url);

        // Clean up diff file (no longer needed)
        await _workspaceService.DeleteDiffAsync(ticketId);

        _logger.LogInformation("Pull request created successfully for ticket {TicketId}: {PrUrl}",
            ticketId, pr.Url);

        return PullRequestCreationResult.Successful(pr.Url, pr.Number);
    }
    catch (LibGit2SharpException ex)
    {
        _logger.LogError(ex, "Git error creating pull request for ticket {TicketId}", ticketId);
        return PullRequestCreationResult.Failed($"Git error: {ex.Message}");
    }
    catch (HttpRequestException ex)
    {
        _logger.LogError(ex, "HTTP error creating pull request for ticket {TicketId}", ticketId);
        return PullRequestCreationResult.Failed($"Platform API error: {ex.Message}");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Unexpected error creating pull request for ticket {TicketId}", ticketId);
        return PullRequestCreationResult.Failed($"Error creating PR: {ex.Message}");
    }
}
```

### Task 5.3: Add Domain Method to Ticket Entity

**File**: `/src/PRFactory.Domain/Entities/Ticket.cs`

**Add method** (if not already exists):

```csharp
/// <summary>
/// Marks the ticket as having a PR created.
/// Transitions state to PRCreated.
/// </summary>
/// <param name="prNumber">Pull request number</param>
/// <param name="prUrl">Pull request URL</param>
public void MarkPRCreated(int prNumber, string prUrl)
{
    if (State != WorkflowState.Implementing)
    {
        throw new InvalidOperationException(
            $"Cannot mark PR created when ticket is in {State} state. Expected Implementing.");
    }

    if (string.IsNullOrWhiteSpace(prUrl))
        throw new ArgumentException("PR URL cannot be empty", nameof(prUrl));

    PullRequestNumber = prNumber;
    PullRequestUrl = prUrl;
    State = WorkflowState.PRCreated;
    UpdatedAt = DateTime.UtcNow;

    _logger.LogInformation("Ticket {TicketKey} marked as PR created: {PrUrl}", Key, prUrl);
}
```

**Add properties** (if not already exists):

```csharp
/// <summary>
/// Pull request number (e.g., 123 for PR #123)
/// </summary>
public int? PullRequestNumber { get; private set; }

/// <summary>
/// Pull request URL
/// </summary>
public string? PullRequestUrl { get; private set; }
```

### Task 5.4: Handle Rejection Workflow (Optional)

**File**: `/src/PRFactory.Web/Pages/Tickets/Detail.razor.cs`

**Implement** `HandleRejectChanges` method:

```csharp
private async Task HandleRejectChanges()
{
    if (Ticket == null)
        return;

    var confirmed = await DialogService.ShowConfirmAsync(
        "Reject Changes",
        "Are you sure you want to reject these changes? This will request the agent to regenerate the code.",
        "Reject",
        "Cancel");

    if (!confirmed)
        return;

    try
    {
        // Transition back to a state that triggers re-implementation
        // (Exact workflow TBD - may need new state or workflow event)

        await TicketService.RejectImplementationAsync(Ticket.Id, User?.Identity?.Name);

        ToastService.ShowSuccess("Changes rejected. Implementation will be regenerated.");

        await LoadTicketAsync();
    }
    catch (Exception ex)
    {
        ToastService.ShowError($"Error rejecting changes: {ex.Message}");
    }
}
```

**Note**: Rejection workflow requires additional design (not critical for MVP).

## Acceptance Criteria

- [ ] PR description includes plan artifacts (user stories, API design, schema, tests, steps)
- [ ] PR description falls back to basic format if plan unavailable
- [ ] PR created via correct platform provider (GitHub/Bitbucket/Azure DevOps)
- [ ] Ticket state transitions to `PRCreated`
- [ ] Ticket stores PR number and URL
- [ ] Diff file cleaned up after PR creation
- [ ] Error handling for git push failures
- [ ] Error handling for platform API failures
- [ ] Comprehensive logging

## Testing

### Integration Tests

**File**: `/tests/PRFactory.Infrastructure.Tests/Application/TicketApplicationServiceIntegrationTests.cs`

```csharp
[Fact]
public async Task CreatePullRequestAsync_CreatesPR_WithPlanArtifacts()
{
    // Arrange
    var ticket = CreateTestTicket(state: WorkflowState.Implementing);
    var plan = CreateTestPlan(ticket.Id, includeAllArtifacts: true);

    await _ticketRepo.AddAsync(ticket);
    await _planRepo.AddAsync(plan);

    // Mock git platform provider
    _gitPlatformProviderMock.Setup(x => x.CreatePullRequestAsync(
        It.IsAny<Guid>(), It.IsAny<CreatePullRequestRequest>()))
        .ReturnsAsync(new PullRequest
        {
            Number = 123,
            Url = "https://github.com/org/repo/pull/123"
        });

    // Act
    var result = await _service.CreatePullRequestAsync(ticket.Id, "test-user");

    // Assert
    Assert.True(result.Success);
    Assert.Equal(123, result.PullRequestNumber);
    Assert.Contains("github.com", result.PullRequestUrl);

    // Verify PR description included plan artifacts
    _gitPlatformProviderMock.Verify(x => x.CreatePullRequestAsync(
        It.IsAny<Guid>(),
        It.Is<CreatePullRequestRequest>(req =>
            req.Description.Contains("User Stories") &&
            req.Description.Contains("API Design") &&
            req.Description.Contains("Database Changes"))),
        Times.Once);

    // Verify ticket state updated
    var updatedTicket = await _ticketRepo.GetByIdAsync(ticket.Id);
    Assert.Equal(WorkflowState.PRCreated, updatedTicket.State);
    Assert.Equal(123, updatedTicket.PullRequestNumber);
}
```

### Manual Testing Checklist

- [ ] Create PR with full plan artifacts
- [ ] Create PR with minimal plan (fallback to basic description)
- [ ] Verify PR appears on GitHub/Bitbucket/Azure DevOps
- [ ] Verify ticket state transitions correctly
- [ ] Verify diff file deleted after PR creation
- [ ] Test error handling (push fails, API fails)

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Platform API rate limits | Medium | Implement retry logic with exponential backoff |
| Large PR descriptions (>65KB) | Low | Truncate plan artifacts if description too large |
| Authentication failures | High | Validate access tokens before PR creation |
| Network failures during push | Medium | Retry logic + user-friendly error messages |

## Next Steps

- **Phase 6**: Testing & integration
- Update IMPLEMENTATION_STATUS.md after merge
