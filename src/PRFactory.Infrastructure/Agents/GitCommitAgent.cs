using Microsoft.Extensions.Logging;
using PRFactory.Domain.Interfaces;
using PRFactory.Domain.ValueObjects;
using PRFactory.Infrastructure.Agents.Base;
using PRFactory.Infrastructure.Git;

namespace PRFactory.Infrastructure.Agents;

/// <summary>
/// Commits implemented code to a feature branch.
/// Creates a new branch, commits code changes, and pushes to remote.
/// </summary>
public class GitCommitAgent : BaseAgent
{
    private readonly ILocalGitService _localGitService;
    private readonly ITicketRepository _ticketRepository;

    public override string Name => "GitCommitAgent";
    public override string Description => "Commit implemented code to feature branch and push to remote";

    public GitCommitAgent(
        ILogger<GitCommitAgent> logger,
        ILocalGitService localGitService,
        ITicketRepository ticketRepository)
        : base(logger)
    {
        _localGitService = localGitService ?? throw new ArgumentNullException(nameof(localGitService));
        _ticketRepository = ticketRepository ?? throw new ArgumentNullException(nameof(ticketRepository));
    }

    protected override async Task<AgentResult> ExecuteAsync(AgentContext context, CancellationToken cancellationToken)
    {
        if (context.Ticket == null)
        {
            Logger.LogError("Ticket entity is missing from context");
            return new AgentResult
            {
                Status = AgentStatus.Failed,
                Error = "Ticket entity is required"
            };
        }

        if (string.IsNullOrEmpty(context.RepositoryPath))
        {
            Logger.LogError("Repository path is missing from context");
            return new AgentResult
            {
                Status = AgentStatus.Failed,
                Error = "Repository path is required"
            };
        }

        // Get implementation from context (populated by ImplementationAgent)
        if (!context.State.ContainsKey("Implementation"))
        {
            Logger.LogError("Implementation code is missing from context");
            return new AgentResult
            {
                Status = AgentStatus.Failed,
                Error = "Implementation code must be generated first"
            };
        }

        Logger.LogInformation("Committing implementation code for ticket {JiraKey}", context.Ticket.TicketKey);

        try
        {
            // Generate branch name
            var branchName = $"feature/{context.Ticket.TicketKey.ToLowerInvariant()}-implementation";
            context.ImplementationBranchName = branchName;

            Logger.LogInformation("Creating implementation branch {BranchName}", branchName);

            // Create and checkout new branch
            await _localGitService.CreateBranchAsync(
                context.RepositoryPath,
                branchName,
                "main" // fromBranch - TODO: use repository's default branch
            );

            // Get files to commit from context
            // TODO: Parse implementation JSON and write files
            // For now, create a placeholder to mark implementation completion
            var implementationMarkerPath = Path.Combine(context.RepositoryPath, ".prfactory-implementation");
            await File.WriteAllTextAsync(
                implementationMarkerPath,
                $"Implementation for {context.Ticket.TicketKey}\nCompleted: {DateTime.UtcNow:O}",
                cancellationToken);

            // Commit changes
            var commitMessage = $"Implement {context.Ticket.TicketKey}: {context.Ticket.Title}\n\nGenerated by PRFactory AI";
            var filesToCommit = new Dictionary<string, string>
            {
                [".prfactory-implementation"] = context.State["Implementation"].ToString()!
            };

            await _localGitService.CommitAsync(
                context.RepositoryPath,
                filesToCommit,
                commitMessage,
                "PRFactory AI <ai@prfactory.dev>"
            );

            Logger.LogInformation("Committed implementation code");

            // Push to remote (TODO: need access token)
            // await _localGitService.PushAsync(context.RepositoryPath, branchName, accessToken);
            Logger.LogWarning("Push to remote not yet implemented - missing access token");

            // Update ticket
            // Note: SetImplementationBranch method doesn't exist yet
            // context.Ticket.SetImplementationBranch(branchName);

            // Transition to Implementing state
            var transitionResult = context.Ticket.TransitionTo(WorkflowState.Implementing);
            if (!transitionResult.IsSuccess)
            {
                Logger.LogError("Failed to transition to Implementing: {Error}", transitionResult.ErrorMessage);
                return new AgentResult
                {
                    Status = AgentStatus.Failed,
                    Error = transitionResult.ErrorMessage
                };
            }

            await _ticketRepository.UpdateAsync(context.Ticket, cancellationToken);

            Logger.LogInformation("Implementation code committed for ticket {JiraKey}", context.Ticket.TicketKey);

            return new AgentResult
            {
                Status = AgentStatus.Completed,
                Output = new Dictionary<string, object>
                {
                    ["BranchName"] = branchName,
                    ["CommitSha"] = "sha-placeholder", // TODO: Get actual SHA from commit
                    ["BranchUrl"] = $"https://github.com/org/repo/tree/{branchName}"
                }
            };
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to commit implementation for ticket {JiraKey}", context.Ticket.TicketKey);
            return new AgentResult
            {
                Status = AgentStatus.Failed,
                Error = $"Failed to commit implementation: {ex.Message}",
                ErrorDetails = ex.ToString()
            };
        }
    }
}
