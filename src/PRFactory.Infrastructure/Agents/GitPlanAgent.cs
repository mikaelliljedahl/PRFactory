using Microsoft.Extensions.Logging;
using PRFactory.Core.Application.Services;
using PRFactory.Domain.Entities;
using PRFactory.Domain.Interfaces;
using PRFactory.Domain.ValueObjects;
using PRFactory.Infrastructure.Agents.Base;
using PRFactory.Infrastructure.Git;

namespace PRFactory.Infrastructure.Agents;

/// <summary>
/// Commits the implementation plan to a feature branch.
/// Creates a new branch, commits IMPLEMENTATION_PLAN.md, and pushes to remote.
/// </summary>
public class GitPlanAgent : BaseAgent
{
    private readonly ILocalGitService _localGitService;
    private readonly ITicketRepository _ticketRepository;
    private readonly IPlanService _planService;

    public override string Name => "GitPlanAgent";
    public override string Description => "Commit implementation plan to feature branch and push to remote";

    public GitPlanAgent(
        ILogger<GitPlanAgent> logger,
        ILocalGitService localGitService,
        ITicketRepository ticketRepository,
        IPlanService planService)
        : base(logger)
    {
        _localGitService = localGitService ?? throw new ArgumentNullException(nameof(localGitService));
        _ticketRepository = ticketRepository ?? throw new ArgumentNullException(nameof(ticketRepository));
        _planService = planService ?? throw new ArgumentNullException(nameof(planService));
    }

    protected override async Task<AgentResult> ExecuteAsync(AgentContext context, CancellationToken cancellationToken)
    {
        if (context.Ticket == null)
        {
            Logger.LogError("Ticket entity is missing from context");
            return new AgentResult
            {
                Status = AgentStatus.Failed,
                Error = "Ticket entity is required"
            };
        }

        if (string.IsNullOrEmpty(context.RepositoryPath))
        {
            Logger.LogError("Repository path is missing from context");
            return new AgentResult
            {
                Status = AgentStatus.Failed,
                Error = "Repository path is required"
            };
        }

        if (string.IsNullOrEmpty(context.ImplementationPlan))
        {
            Logger.LogError("Implementation plan is missing from context");
            return new AgentResult
            {
                Status = AgentStatus.Failed,
                Error = "Implementation plan must be generated first"
            };
        }

        Logger.LogInformation("Committing implementation plan for ticket {JiraKey}", context.Ticket.TicketKey);

        try
        {
            // Generate branch name
            var branchName = $"feature/{context.Ticket.TicketKey.ToLowerInvariant()}-implementation-plan";
            context.PlanBranchName = branchName;

            Logger.LogInformation("Creating feature branch {BranchName}", branchName);

            // Create and checkout new branch
            // Note: CheckoutAsync not yet implemented in ILocalGitService
            await _localGitService.CreateBranchAsync(
                context.RepositoryPath,
                branchName,
                "main" // fromBranch - TODO: use repository's default branch
            );

            // TODO: Checkout branch when CheckoutAsync is implemented

            // Write implementation plan to file
            var planFilePath = Path.Combine(context.RepositoryPath, "IMPLEMENTATION_PLAN.md");
            await File.WriteAllTextAsync(planFilePath, context.ImplementationPlan, cancellationToken);

            Logger.LogInformation("Wrote implementation plan to {FilePath}", planFilePath);

            // Stage and commit the file
            // Note: StageFileAsync not yet implemented - using CommitAsync directly

            // Commit
            var commitMessage = $"Add implementation plan for {context.Ticket.TicketKey}\n\nGenerated by PRFactory AI";
            var filesToCommit = new Dictionary<string, string>
            {
                ["IMPLEMENTATION_PLAN.md"] = context.ImplementationPlan
            };
            await _localGitService.CommitAsync(
                context.RepositoryPath,
                filesToCommit,
                commitMessage,
                "PRFactory AI <ai@prfactory.dev>"
            );

            Logger.LogInformation("Committed implementation plan");

            // Push to remote (TODO: need access token)
            Logger.LogWarning("Push to remote not yet implemented - missing access token");

            Logger.LogInformation("Pushed branch {BranchName} to remote", branchName);

            // Update ticket
            context.Ticket.SetPlanBranch(branchName);

            // Transition to PlanPosted state
            var transitionResult = context.Ticket.TransitionTo(WorkflowState.PlanPosted);
            if (!transitionResult.IsSuccess)
            {
                Logger.LogError("Failed to transition to PlanPosted: {Error}", transitionResult.ErrorMessage);
                return new AgentResult
                {
                    Status = AgentStatus.Failed,
                    Error = transitionResult.ErrorMessage
                };
            }

            await _ticketRepository.UpdateAsync(context.Ticket, cancellationToken);

            // Create initial plan revision after plan committed to git
            try
            {
                await _planService.CreateRevisionAsync(
                    context.Ticket.Id,
                    PlanRevisionReason.Initial);

                Logger.LogInformation(
                    "Created initial plan revision for ticket {TicketId}",
                    context.Ticket.Id);
            }
            catch (Exception ex)
            {
                // Log error but don't fail the workflow - revision creation is not critical
                Logger.LogError(ex,
                    "Failed to create initial plan revision for ticket {TicketId}, continuing workflow",
                    context.Ticket.Id);
            }

            Logger.LogInformation("Implementation plan committed and pushed for ticket {JiraKey}", context.Ticket.TicketKey);

            return new AgentResult
            {
                Status = AgentStatus.Completed,
                Output = new Dictionary<string, object>
                {
                    ["BranchName"] = branchName,
                    ["PlanFilePath"] = planFilePath
                }
            };
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to commit plan for ticket {JiraKey}", context.Ticket.TicketKey);
            return new AgentResult
            {
                Status = AgentStatus.Failed,
                Error = $"Failed to commit plan: {ex.Message}",
                ErrorDetails = ex.ToString()
            };
        }
    }
}
