using Microsoft.Extensions.Logging;
using PRFactory.Domain.Interfaces;
using PRFactory.Domain.ValueObjects;
using PRFactory.Infrastructure.Agents.Base;
using PRFactory.Infrastructure.Git;

namespace PRFactory.Infrastructure.Agents;

/// <summary>
/// Commits the implementation plan to a feature branch.
/// Creates a new branch, commits IMPLEMENTATION_PLAN.md, and pushes to remote.
/// </summary>
public class GitPlanAgent : BaseAgent
{
    private readonly ILocalGitService _localGitService;
    private readonly ITicketRepository _ticketRepository;

    public override string Name => "GitPlanAgent";
    public override string Description => "Commit implementation plan to feature branch and push to remote";

    public GitPlanAgent(
        ILogger<GitPlanAgent> logger,
        ILocalGitService localGitService,
        ITicketRepository ticketRepository)
        : base(logger)
    {
        _localGitService = localGitService ?? throw new ArgumentNullException(nameof(localGitService));
        _ticketRepository = ticketRepository ?? throw new ArgumentNullException(nameof(ticketRepository));
    }

    protected override async Task<AgentResult> ExecuteAsync(AgentContext context, CancellationToken cancellationToken)
    {
        if (context.Ticket == null)
        {
            Logger.LogError("Ticket entity is missing from context");
            return new AgentResult
            {
                Status = AgentStatus.Failed,
                Error = "Ticket entity is required"
            };
        }

        if (string.IsNullOrEmpty(context.RepositoryPath))
        {
            Logger.LogError("Repository path is missing from context");
            return new AgentResult
            {
                Status = AgentStatus.Failed,
                Error = "Repository path is required"
            };
        }

        if (string.IsNullOrEmpty(context.ImplementationPlan))
        {
            Logger.LogError("Implementation plan is missing from context");
            return new AgentResult
            {
                Status = AgentStatus.Failed,
                Error = "Implementation plan must be generated first"
            };
        }

        Logger.LogInformation("Committing implementation plan for ticket {JiraKey}", context.Ticket.TicketKey);

        try
        {
            // Generate branch name
            var branchName = $"feature/{context.Ticket.TicketKey.ToLowerInvariant()}-implementation-plan";
            context.PlanBranchName = branchName;

            Logger.LogInformation("Creating feature branch {BranchName}", branchName);

            // Create and checkout new branch
            // Note: CheckoutAsync not yet implemented in ILocalGitService
            await _localGitService.CreateBranchAsync(
                context.RepositoryPath,
                branchName,
                "main" // fromBranch - TODO: use repository's default branch
            );

            // TODO: Checkout branch when CheckoutAsync is implemented
            // await _localGitService.CheckoutAsync(context.RepositoryPath, branchName, cancellationToken);

            // Write implementation plan to file
            var planFilePath = Path.Combine(context.RepositoryPath, "IMPLEMENTATION_PLAN.md");
            await File.WriteAllTextAsync(planFilePath, context.ImplementationPlan, cancellationToken);

            Logger.LogInformation("Wrote implementation plan to {FilePath}", planFilePath);

            // Stage and commit the file
            // Note: StageFileAsync not yet implemented - using CommitAsync directly
            // await _localGitService.StageFileAsync(context.RepositoryPath, "IMPLEMENTATION_PLAN.md", cancellationToken);

            // Commit
            var commitMessage = $"Add implementation plan for {context.Ticket.TicketKey}\n\nGenerated by PRFactory AI";
            await _localGitService.CommitAsync(
                context.RepositoryPath,
                commitMessage,
                cancellationToken
            );

            Logger.LogInformation("Committed implementation plan");

            // Push to remote
            await _localGitService.PushAsync(
                context.RepositoryPath,
                branchName,
                cancellationToken
            );

            Logger.LogInformation("Pushed branch {BranchName} to remote", branchName);

            // Update ticket
            context.Ticket.SetPlanBranch(branchName);

            // Transition to PlanPosted state
            var transitionResult = context.Ticket.TransitionTo(WorkflowState.PlanPosted);
            if (!transitionResult.IsSuccess)
            {
                Logger.LogError("Failed to transition to PlanPosted: {Error}", transitionResult.ErrorMessage);
                return new AgentResult
                {
                    Status = AgentStatus.Failed,
                    Error = transitionResult.ErrorMessage
                };
            }

            await _ticketRepository.UpdateAsync(context.Ticket, cancellationToken);

            Logger.LogInformation("Implementation plan committed and pushed for ticket {JiraKey}", context.Ticket.TicketKey);

            return new AgentResult
            {
                Status = AgentStatus.Completed,
                Output = new Dictionary<string, object>
                {
                    ["BranchName"] = branchName,
                    ["PlanFilePath"] = planFilePath
                }
            };
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to commit plan for ticket {JiraKey}", context.Ticket.TicketKey);
            return new AgentResult
            {
                Status = AgentStatus.Failed,
                Error = $"Failed to commit plan: {ex.Message}",
                ErrorDetails = ex.ToString()
            };
        }
    }
}
